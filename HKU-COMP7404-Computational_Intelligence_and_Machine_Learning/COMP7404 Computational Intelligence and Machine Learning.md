### 1.5 Uninformed - UCS

* UCS explores the cheapest node first

```{python}
from heapq import heappush, heappop
def ucsGsa(stateSpaceGraph, startState, goalState):
    frontier = []
    heappush(frontier, (0, startState))
    exploredSet = set()
    while frontier:
        node = heappop(frontier)
        if (node[1].endswith(goalState)): return node
    	if node[1][-1] not in exploredSet:
            exploredSet.add(node[1][-1])
            for child in stateSpaceGraph[node[1][-1]]:
                heappush(frontier, (node[0]+child[0], node[1]+child[1])) # arithmetically plus vs string concatenation
                print(list(frontier)); print(exploredSet); input()
```

if all the cost is 0, UCG becomes DFS

| Completeness (TSA) | Optimality | Time complexity              | Space complexity                     |
| ------------------ | ---------- | ---------------------------- | ------------------------------------ |
| UNLESS (cost = 0)  | YES        | $b^0+b^1+...+b^d-1 = O(b^d)$ | $(b-1)\times (d-1)+b = O(b\times d)$ |

> * $C^\star$: cost of optimal solution
> * $\epsilon$: smallest path cost in search graph
> * $d={C^\star\over \epsilon}$: estimate of the depth of shallowest solution

### 1.6 Informed - Greedy

### 1.7 Informed - A*

###1.8 Local Search

#### Concepts

**Planning vs. Identification**

* Planning: sequences of actions
  * The path to the goal is the important thing
  * Paths have various costs, depths
  * Heuristics to guide, frontier to keep backups
* Identification: assignments to variables
  * The goal itself is important, not the path

* Local Search can find solutions faster for specific types of identification problems

* Evaluate and modify one current state rather than systematically explore paths from an initial state
* Suitable for problems were all that matters is the solution state and not the path cost to reach it
* Although local search algorithms are not systematic they have two advantages
  * Require very little memory
  * Often find reasonable solutions in large spaces

* Suitable for problems have many solution distributed everywhere, e.g. 8-queens.

#### 8-Queens

* States: Each state has 8 queens on the board, one per column
* Successors: All possible states generated by moving a single queen to another square in the same column
* Cost function: Number of **pairs** of queens that are attacking each other, either directly or indirectly

> * How many neighbors does the following state have?
>
>   Every queen can move to 7 locations. There are 7*8 = 56 neighbors.

#### Algorithm

1. Randomly initialize currentState

2. If cost of currentState == 0 return currentState

3. If min(cost(getNeighbors(currentState))) > cost(currentState)

   â€‹	goto step 1 (we have reached a local minimum)

4. Select cheapest neighbor as currentState and goto step 2

01:18:00

00:26:45



## 2 Markov Decision Processes













